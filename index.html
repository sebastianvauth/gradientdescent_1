<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introduction to Optimization and the Need for Gradient Descent</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #ffffff;
            font-size: 150%;
        }
        section {
            margin-bottom: 20px;
            padding: 20px;
            background-color: #ffffff;
            display: none;
            opacity: 0;
            transition: opacity 0.5s ease-in;
        }
        h1, h2, h3, h4 {
            color: #333;
            margin-top: 20px;
        }
        p, li {
            line-height: 1.6;
            color: #444;
            margin-bottom: 20px;
        }
        ul {
            padding-left: 20px;
        }
        .image-placeholder, .interactive-placeholder, .continue-button, .vocab-section, .why-it-matters, .test-your-knowledge, .faq-section, .stop-and-think {
            text-align: left;
        }
        .image-placeholder img, .interactive-placeholder img {
            max-width: 100%;
            height: auto;
            border-radius: 5px;
        }
        .vocab-section, .why-it-matters, .test-your-knowledge, .faq-section, .stop-and-think {
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }
        .vocab-section {
            background-color: #f0f8ff;
        }
        .vocab-section h3 {
            color: #1e90ff;
            font-size: 0.75em;
            margin-bottom: 5px;
            margin-top: 5px;
        }
        .vocab-section h4 {
            color: #000;
            font-size: 0.9em;
            margin-top: 10px;
            margin-bottom: 8px;
        }
        .vocab-term {
            font-weight: bold;
            color: #1e90ff;
        }
        .why-it-matters {
            background-color: #ffe6f0;
        }
        .why-it-matters h3 {
            color: #d81b60;
            font-size: 0.75em;
            margin-bottom: 5px;
            margin-top: 5px;
        }
        .stop-and-think {
            background-color: #e6e6ff;
        }
        .stop-and-think h3 {
            color: #4b0082;
            font-size: 0.75em;
            margin-bottom: 5px;
            margin-top: 5px;
        }
        .continue-button {
            display: inline-block;
            padding: 10px 20px;
            margin-top: 15px;
            color: #ffffff;
            background-color: #007bff;
            border-radius: 5px;
            text-decoration: none;
            cursor: pointer;
        }
        .reveal-button {
            display: inline-block;
            padding: 10px 20px;
            margin-top: 15px;
            color: #ffffff;
            background-color: #4b0082;
            border-radius: 5px;
            text-decoration: none;
            cursor: pointer;
        }
        .test-your-knowledge {
            background-color: #e6ffe6;
        }
        .test-your-knowledge h3 {
            color: #28a745;
            font-size: 0.75em;
            margin-bottom: 5px;
            margin-top: 5px;
        }
        .test-your-knowledge h4 {
            color: #000;
            font-size: 0.9em;
            margin-top: 10px;
            margin-bottom: 8px;
        }
        .test-your-knowledge p {
            margin-bottom: 15px;
        }
        .check-button {
            display: inline-block;
            padding: 10px 20px;
            margin-top: 15px;
            color: #ffffff;
            background-color: #28a745;
            border-radius: 5px;
            text-decoration: none;
            cursor: pointer;
            border: none;
            font-size: 1em;
        }
        .faq-section {
            background-color: #fffbea;
        }
        .faq-section h3 {
            color: #ffcc00;
            font-size: 0.75em;
            margin-bottom: 5px;
            margin-top: 5px;
        }
        .faq-section h4 {
            color: #000;
            font-size: 0.9em;
            margin-top: 10px;
            margin-bottom: 8px;
        }

        /* Interactive Styles */
        .interactive-container {
            width: 100%;
            height: 400px;
            background: #f8f9fa;
            border-radius: 12px;
            margin: 20px 0;
            position: relative;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .interactive-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 10;
        }

        .interactive-button {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .interactive-button:hover {
            background: #0056b3;
        }

        .interactive-button.reset {
            background: #6c757d;
        }

        .interactive-button.reset:hover {
            background: #545b62;
        }

        .tooltip {
            position: absolute;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 4px;
            font-size: 14px;
            pointer-events: none;
            z-index: 100;
        }

        /* Basketball Interactive Specific Styles */
        .basketball {
            fill: #ff7043;
            stroke: #e64a19;
            stroke-width: 2;
        }

        .trajectory {
            fill: none;
            stroke-width: 2;
            stroke-dasharray: 4;
        }

        .trajectory.success {
            stroke: #4caf50;
        }

        .trajectory.failure {
            stroke: #f44336;
        }

        /* Landscape Interactive Specific Styles */
        .contour {
            fill: none;
            stroke: #546e7a;
            stroke-width: 0.5;
        }

        .elevation-point {
            fill: #ff5722;
            stroke: white;
            stroke-width: 2;
            cursor: pointer;
        }

        .grid-line {
            stroke: rgba(0, 0, 0, 0.1);
            stroke-width: 0.5;
        }

        /* Gradient Descent Interactive Specific Styles */
        .gradient-path {
            fill: none;
            stroke: #ff5722;
            stroke-width: 3;
            stroke-linecap: round;
        }

        .gradient-point {
            fill: #ff5722;
            stroke: white;
            stroke-width: 2;
        }

        .gradient-arrow {
            fill: #ff5722;
            stroke: none;
        }
    </style>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <section id="section1">
<img src="/placeholder.svg?height=300&width=600" alt="A hiker standing at a crossroads on a mountain path, looking at a map, symbolizing the need to choose the right direction in optimization, just as a hiker chooses the best path to reach their destination.">
        </div>
        <h1>Finding the Sweet Spot: Why We Need Gradient Descent</h1>
        <div class="image-placeholder">
            
        <p>In many machine learning tasks, our goal is to find the best set of parameters for our model that minimize the error or, in other words, minimize the cost function. Think of it as trying to find the lowest point in a vast, hilly landscape, and you are a hiker trying to find your way down. You could try to measure the elevation at every single point, but that would take forever, especially if the landscape is enormous. This is similar to what happens when we try to calculate the least squares solution directly for datasets with millions or billions of data points.</p>
        <div class="continue-button" onclick="showNextSection(2)">Continue</div>
    </section>

    <section id="section2">
        <h2>Understanding the Cost Function</h2>
        <p>Let's introduce the idea of a <strong>cost function</strong>. Imagine you're learning to shoot basketball. Every time you miss, you feel a bit of disappointment, right? That feeling is similar to what a cost function represents in machine learning.</p>
        <div class="interactive-placeholder">
            <div id="basketball-interactive" class="interactive-container"></div>
            <p>Just like varying degrees of misses in basketball, the cost function quantifies how far our model's predictions are from the actual values.</p>
        </div>
        <p>The cost function measures how 'wrong' our model's predictions are compared to the actual values. The higher the cost, the worse our model is performing. Our ultimate goal? To find the model parameters that make this cost function as small as possible, like perfecting your shot to hit the basket every time.</p>
  <div class="continue-button" onclick="showNextSection(3)">Continue</div>
    </section>

    <section id="section3">
        <div class="vocab-section">
            <h3>Build Your Vocab</h3>
            <h4 class="vocab-term">Cost Function</h4>
            <p>A function that measures the error or 'wrongness' of a machine learning model's predictions. It's a way to quantify the difference between what the model predicts and what the actual values are. The goal in many machine learning tasks is to minimize this function.</p>
        </div>
        <div class="continue-button" onclick="showNextSection(4)">Continue</div>
    </section>

    <section id="section4">
        <h2>The Inefficiency of Brute Force</h2>
        <p>Now, you might think, 'Why not just try out all possible combinations of parameters and see which one gives the lowest cost?' That's like trying to find the lowest point in our hilly landscape by measuring the elevation at every single spot. Sounds exhausting, doesn't it?</p>
        <div class="interactive-placeholder">
            <div id="landscape-interactive" class="interactive-container"></div>
            <p>Click on different points to see the elevation. Try to find the lowest point. Imagine having to do this for every single point in a much larger landscape!</p>
        </div>
        <p>For small datasets, this brute-force approach might be feasible. But as datasets grow larger, with millions or even billions of data points, it becomes incredibly time-consuming and computationally expensive. It's like trying to find a needle in a haystack by examining every single piece of hay.</p>
        <div class="continue-button" onclick="showNextSection(5)">Continue</div>
    </section>

    <section id="section5">
        <h2>Introducing Gradient Descent: The Smart Way Down</h2>
        <p>This is where Gradient Descent comes to the rescue. Instead of examining every single point, we'll use a clever iterative method to 'walk down' the landscape towards the lowest point. Think of it as a smart hiker who uses the slope of the terrain to guide their steps, always moving downhill.</p>
        <div class="interactive-placeholder">
            <div id="gradient-descent-interactive" class="interactive-container"></div>
            <p>Like a smart hiker, Gradient Descent uses the 'slope' of the cost function to find the most efficient path to the minimum.</p>
        </div>
        <p>Gradient Descent is like our smart hiker. It starts at a random point and takes steps in the direction of the steepest decrease in the cost function. With each step, it gets closer to the bottom, the point where the cost is minimized.</p>
        <div class="continue-button" onclick="showNextSection(6)">Continue</div>
    </section>

    <section id="section6">
                <div class="why-it-matters">
            <h3>Why It Matters</h3>
            <p>Gradient Descent is a fundamental optimization algorithm used in various machine learning models, from linear regression to deep neural networks. It provides an efficient way to train models on large datasets, making it a crucial tool for any machine learning practitioner. By helping us find the optimal model parameters, Gradient Descent enables us to build accurate and powerful predictive models that can solve real-world problems.</p>
        </div>
        <div class="continue-button" onclick="showNextSection(7)">Continue</div>
    </section>

    <section id="section7">
                <div class="faq-section">
            <h3>Frequently Asked Questions</h3>
            <h4>Is Gradient Descent always the best optimization method?</h4>
            <p>While Gradient Descent is powerful and widely used, it's not always the best choice for every situation. There are other optimization algorithms, each with its strengths and weaknesses. The best choice depends on the specific problem, the size of the dataset, and the complexity of the model.</p>
            <h4>Can Gradient Descent get stuck?</h4>
            <p>Yes, it's possible. Imagine our hiker getting stuck in a small dip on the mountainside, thinking they've reached the bottom when there's actually a deeper valley elsewhere. We'll explore this in more detail in later lessons, but for now, know that it's something to be aware of.</p>
        </div>
        <div class="continue-button" onclick="showNextSection(8)">Continue</div>
    </section>

    <section id="section8">
                <div class="vocab-section">
            <h3>Build Your Vocab</h3>
            <h4 class="vocab-term">Optimization</h4>
            <p>The process of finding the best set of parameters for a model that minimize a given cost function. It's like tuning the settings of a machine to make it work as efficiently as possible.</p>
            <h4 class="vocab-term">Least Squares Solution</h4>
            <p>A method for finding the best-fitting line (or hyperplane) by minimizing the sum of the squared differences between the observed and predicted values. It's a way to find the 'average' best fit, but it can be computationally expensive for large datasets.</p>
        </div>
        <div class="continue-button" onclick="showNextSection(9)">Continue</div>
    </section>

    <section id="section9">
                <div class="stop-and-think">
            <h3>Stop and Think</h3>
            <h4>Imagine you're trying to teach a robot to navigate a maze. How could the concept of a cost function be applied in this scenario? What might the 'cost' represent?</h4>
            <p>Think about what you want the robot to achieve and what you want it to avoid in the maze.</p>
            <button class="reveal-button" onclick="revealAnswer('stop-and-think-1')">Reveal</button>
            <p id="stop-and-think-1" style="display: none;">In this scenario, the cost function could represent the time taken or distance traveled by the robot to reach the end of the maze. The 'cost' might increase for every wrong turn, collision with a wall, or step taken. The goal would be to minimize this cost, effectively finding the quickest or shortest path through the maze. The robot would learn to optimize its path by minimizing this cost function through repeated attempts, much like how machine learning models improve through training.</p>
        </div>
        <div class="continue-button" onclick="showNextSection(10)">Continue</div>
    </section>

    
    <section id="section10">
        <p>Great job completing the first lesson! You've now been introduced to the concept of optimization and learned why Gradient Descent is a crucial tool in machine learning. You've also started building your vocabulary and understanding the importance of cost functions. In the next lesson, we'll dive deeper into the mechanics of Gradient Descent and see how it actually works step-by-step. Get ready to explore the exciting world of iterative optimization!</p>
      
    </section>

    <script>
        // Show the first section initially
        document.getElementById("section1").style.display = "block";
        document.getElementById("section1").style.opacity = "1";

        function showNextSection(nextSectionId) {
            const currentButton = event.target;
            const nextSection = document.getElementById("section" + nextSectionId);
            
            currentButton.style.display = "none";
            
            nextSection.style.display = "block";
            setTimeout(() => {
                nextSection.style.opacity = "1";
            }, 10);

            setTimeout(() => {
                nextSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }, 500);
        }

        function revealAnswer(id) {
            const revealText = document.getElementById(id);
            const revealButton = event.target;
            
            revealText.style.display = "block";
            revealButton.style.display = "none";
        }

        function checkAnswer() {
            const form = document.getElementById('quiz-form');
            const result = document.getElementById('quiz-result');
            const selectedAnswer = form.querySelector('input[name="quiz"]:checked');

            if (selectedAnswer) {
                const answerIndex = parseInt(selectedAnswer.value);
                const explanations = [
                    "While Gradient Descent can achieve high accuracy, its main advantage over direct calculation isn't necessarily higher accuracy, but rather efficiency, especially for large datasets.",
                    "Correct! Gradient Descent's iterative approach makes it much more efficient for optimizing models on large datasets compared to the computationally expensive direct calculation of the least squares solution.",
                    "The concept of Gradient Descent might seem more complex at first due to its iterative nature, but its efficiency advantage is the key reason for its widespread use.",
                    "The amount of data needed doesn't directly determine the choice between Gradient Descent and direct least squares calculation. The efficiency in handling large datasets is the primary factor."
                ];

                result.textContent = explanations[answerIndex];
                result.style.color = answerIndex === 1 ? 'green' : 'red';
                result.style.display = 'block';
            } else {
                result.textContent = "Please select an answer before checking.";
                result.style.color = 'red';
                result.style.display = 'block';
            }
        }

        // Basketball Interactive
        function initBasketballInteractive() {
            const container = d3.select('#basketball-interactive');
            const width = container.node().getBoundingClientRect().width;
            const height = container.node().getBoundingClientRect().height;
            
            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height);
                
            // Add basketball hoop
            const hoopX = width * 0.8;
            const hoopY = height * 0.3;
            
            svg.append('rect')
                .attr('x', hoopX - 5)
                .attr('y', hoopY)
                .attr('width', 10)
                .attr('height', 60)
                .attr('fill', '#795548');
                
            svg.append('path')
                .attr('d', `M${hoopX - 30},${hoopY} L${hoopX + 30},${hoopY}`)
                .attr('stroke', '#e65100')
                .attr('stroke-width', 5);
                
            // Add floor
            svg.append('line')
                .attr('x1', 0)
                .attr('y1', height * 0.8)
                .attr('x2', width)
                .attr('y2', height * 0.8)
                .attr('stroke', '#90a4ae')
                .attr('stroke-width', 2);
                
            let trajectories = [];
            
            function shootBall(startX, startY, success) {
                const ball = svg.append('circle')
                    .attr('class', 'basketball')
                    .attr('r', 10)
                    .attr('cx', startX)
                    .attr('cy', startY);
                    
                const controlPoint1X = startX + (hoopX - startX) * 0.5;
                const controlPoint1Y = success ? startY - 200 : startY - 100;
                const endX = success ? hoopX : hoopX + (Math.random() * 60 - 30);
                const endY = success ? hoopY : hoopY + (Math.random() * 40 - 20);
                
                const path = `M${startX},${startY} Q${controlPoint1X},${controlPoint1Y} ${endX},${endY}`;
                
                svg.append('path')
                    .attr('class', `trajectory ${success ? 'success' : 'failure'}`)
                    .attr('d', path);
                    
                const pathNode = svg.append('path')
                    .attr('d', path)
                    .style('opacity', 0);
                    
                const pathLength = pathNode.node().getTotalLength();
                
                ball.transition()
                    .duration(1500)
                    .attrTween('transform', () => (t) => {
                        const point = pathNode.node().getPointAtLength(t * pathLength);
                        return `translate(${point.x},${point.y})`;
                    })
                    .on('end', () => {
                        pathNode.remove();
                        ball.remove();
                    });
            }
            
            // Add controls
            const controls = container.append('div')
                .attr('class', 'interactive-controls');
                
            controls.append('button')
                .attr('class', 'interactive-button')
                .text('Shoot Ball')
                .on('click', () => {
                    const success = Math.random() > 0.5;
                    shootBall(width * 0.2, height * 0.7, success);
                });
                
            controls.append('button')
                .attr('class', 'interactive-button reset')
                .text('Clear')
                .on('click', () => {
                    svg.selectAll('.trajectory').remove();
                    svg.selectAll('.basketball').remove();
                });
        }

        // Landscape Interactive
        function initLandscapeInteractive() {
            const container = d3.select('#landscape-interactive');
            const width = container.node().getBoundingClientRect().width;
            const height = container.node().getBoundingClientRect().height;
            
            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height);
                
            // Create a complex landscape using multiple Gaussian functions
            function landscape(x, y) {
                const g1 = Math.exp(-((x - 0.3) ** 2 + (y - 0.3) ** 2) / 0.1);
                const g2 = Math.exp(-((x - 0.7) ** 2 + (y - 0.7) ** 2) / 0.1) * 0.8;
                const g3 = Math.exp(-((x - 0.5) ** 2 + (y - 0.5) ** 2) / 0.2) * 0.5;
                return g1 + g2 - g3;
            }
            
            // Generate contour data
            const n = 50;
            const data = new Array(n * n);
            const x = d3.scaleLinear().domain([0, 1]).range([50, width - 50]);
            const y = d3.scaleLinear().domain([0, 1]).range([50, height - 50]);
            
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    data[i * n + j] = landscape(i / (n - 1), j / (n - 1));
                }
            }
            
            // Create contour generator
            const contours = d3.contours()
                .size([n, n])
                .thresholds(20)(data);
                
            // Add contours
            svg.append('g')
                .selectAll('path')
                .data(contours)
                .enter()
                .append('path')
                .attr('class', 'contour')
                .attr('d', d3.geoPath(d3.geoIdentity().scale(width / n)));
                
            // Add grid
            for (let i = 0; i <= 10; i++) {
                svg.append('line')
                    .attr('class', 'grid-line')
                    .attr('x1', x(i / 10))
                    .attr('y1', y(0))
                    .attr('x2', x(i / 10))
                    .attr('y2', y(1));
                    
                svg.append('line')
                    .attr('class', 'grid-line')
                    .attr('x1', x(0))
                    .attr('y1', y(i / 10))
                    .attr('x2', x(1))
                    .attr('y2', y(i / 10));
            }
            
            // Add tooltip
            const tooltip = container.append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);
                
            // Add click interaction
            svg.on('click', (event) => {
                const [mouseX, mouseY] = d3.pointer(event);
                const xVal = x.invert(mouseX);
                const yVal = y.invert(mouseY);
                const elevation = landscape(xVal, yVal);
                
                svg.append('circle')
                    .attr('class', 'elevation-point')
                    .attr('cx', mouseX)
                    .attr('cy', mouseY)
                    .attr('r', 6);
                    
                tooltip.transition()
                    .duration(200)
                    .style('opacity', 0.9);
                    
                tooltip.html(`Elevation: ${elevation.toFixed(3)}`)
                    .style('left', `${mouseX + 10}px`)
                    .style('top', `${mouseY - 28}px`);
            });
            
            // Add controls
            const controls = container.append('div')
                .attr('class', 'interactive-controls');
                
            controls.append('button')
                .attr('class', 'interactive-button reset')
                .text('Clear Points')
                .on('click', () => {
                    svg.selectAll('.elevation-point').remove();
                    tooltip.style('opacity', 0);
                });
        }

        // Gradient Descent Interactive
        function initGradientDescentInteractive() {
            const container = d3.select('#gradient-descent-interactive');
            const width = container.node().getBoundingClientRect().width;
            const height = container.node().getBoundingClientRect().height;
            
            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height);
                
            // Create a simpler landscape for gradient descent
            function landscape(x, y) {
                return Math.exp(-((x - 0.5) ** 2 + (y - 0.5) ** 2) / 0.2);
            }
            
            function gradient(x, y) {
                const dx = -2 * (x - 0.5) * landscape(x, y) / 0.2;
                const dy = -2 * (y - 0.5) * landscape(x, y) / 0.2;
                return [dx, dy];
            }
            
            // Generate contour data
            const n = 50;
            const data = new Array(n * n);
            const x = d3.scaleLinear().domain([0, 1]).range([50, width - 50]);
            const y = d3.scaleLinear().domain([0, 1]).range([50, height - 50]);
            
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    data[i * n + j] = landscape(i / (n - 1), j / (n - 1));
                }
            }
            
            // Create contour generator
            const contours = d3.contours()
                .size([n, n])
                .thresholds(20)(data);
                
            // Add contours
            svg.append('g')
                .selectAll('path')
                .data(contours)
                .enter()
                .append('path')
                .attr('class', 'contour')
                .attr('d', d3.geoPath(d3.geoIdentity().scale(width / n)));
                
            let currentPath = null;
            let currentPoint = null;
            
            function runGradientDescent(startX, startY) {
                let points = [[startX, startY]];
                let x = startX;
                let y = startY;
                const learningRate = 0.1;
                
                for (let i = 0; i < 50; i++) {
                    const [dx, dy] = gradient(x, y);
                    x += learningRate * dx;
                    y += learningRate * dy;
                    points.push([x, y]);
                    
                    if (Math.abs(dx) < 0.001 && Math.abs(dy) < 0.001) break;
                }
                
                const line = d3.line()
                    .x(d => x(d[0]))
                    .y(d => y(d[1]))
                    .curve(d3.curveCatmullRom);
                    
                if (currentPath) currentPath.remove();
                if (currentPoint) currentPoint.remove();
                
                currentPath = svg.append('path')
                    .attr('class', 'gradient-path')
                    .attr('d', line(points));
                    
                const pathLength = currentPath.node().getTotalLength();
                
                currentPath
                    .attr('stroke-dasharray', pathLength)
                    .attr('stroke-dashoffset', pathLength)
                    .transition()
                    .duration(2000)
                    .attr('stroke-dashoffset', 0);
                    
                currentPoint = svg.append('circle')
                    .attr('class', 'gradient-point')
                    .attr('r', 6)
                    .attr('cx', x(points[0][0]))
                    .attr('cy', y(points[0][1]));
                    
                currentPoint.transition()
                    .duration(2000)
                    .attrTween('transform', () => (t) => {
                        const point = currentPath.node().getPointAtLength(t * pathLength);
                        return `translate(${point.x - x(points[0][0])},${point.y - y(points[0][1])})`;
                    });
            }
            
            // Add controls
            const controls = container.append('div')
                .attr('class', 'interactive-controls');
                
            controls.append('button')
                .attr('class', 'interactive-button')
                .text('Start Random Point')
                .on('click', () => {
                    const startX = Math.random();
                    const startY = Math.random();
                    runGradientDescent(startX, startY);
                });
                
            controls.append('button')
                .attr('class', 'interactive-button reset')
                .text('Clear')
                .on('click', () => {
                    if (currentPath) currentPath.remove();
                    if (currentPoint) currentPoint.remove();
                });
        }

        // Initialize all interactives when the page loads
        window.addEventListener('load', () => {
            initBasketballInteractive();
            initLandscapeInteractive();
            initGradientDescentInteractive();
        });
    </script>
</body>
</html>
