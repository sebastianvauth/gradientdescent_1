<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introduction to Gradient Descent</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #ffffff;
            font-size: 150%;
        }
        section {
            margin-bottom: 20px;
            padding: 20px;
            background-color: #ffffff;
            display: none;
            opacity: 0;
            transition: opacity 0.5s ease-in;
        }
        h1, h2, h3, h4 {
            color: #333;
            margin-top: 20px;
        }
        p, li {
            line-height: 1.6;
            color: #444;
            margin-bottom: 20px;
        }
        ul, ol {
            padding-left: 20px;
        }
        .image-placeholder, .interactive-placeholder, .continue-button, .vocab-section, .why-it-matters, .test-your-knowledge, .faq-section, .stop-and-think {
            text-align: left;
        }
        .image-placeholder img, .interactive-placeholder img {
            max-width: 100%;
            height: auto;
            border-radius: 5px;
        }
        .vocab-section, .why-it-matters, .test-your-knowledge, .faq-section, .stop-and-think {
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }
        .vocab-section {
            background-color: #f0f8ff;
        }
        .vocab-section h3 {
            color: #1e90ff;
            font-size: 0.75em;
            margin-bottom: 5px;
            margin-top: 5px;
        }
        .vocab-section h4 {
            color: #000;
            font-size: 0.9em;
            margin-top: 10px;
            margin-bottom: 8px;
        }
        .vocab-term {
            font-weight: bold;
            color: #1e90ff;
        }
        .why-it-matters {
            background-color: #ffe6f0;
        }
        .why-it-matters h3 {
            color: #d81b60;
            font-size: 0.75em;
            margin-bottom: 5px;
            margin-top: 5px;
        }
        .stop-and-think {
            background-color: #e6e6ff;
        }
        .stop-and-think h3 {
            color: #4b0082;
            font-size: 0.75em;
            margin-bottom: 5px;
            margin-top: 5px;
        }
        .continue-button {
            display: inline-block;
            padding: 10px 20px;
            margin-top: 15px;
            color: #ffffff;
            background-color: #007bff;
            border-radius: 5px;
            text-decoration: none;
            cursor: pointer;
        }
        .reveal-button {
            display: inline-block;
            padding: 10px 20px;
            margin-top: 15px;
            color: #ffffff;
            background-color: #4b0082;
            border-radius: 5px;
            text-decoration: none;
            cursor: pointer;
        }
        .test-your-knowledge {
            background-color: #e6ffe6;
        }
        .test-your-knowledge h3 {
            color: #28a745;
            font-size: 0.75em;
            margin-bottom: 5px;
            margin-top: 5px;
        }
        .test-your-knowledge h4 {
            color: #000;
            font-size: 0.9em;
            margin-top: 10px;
            margin-bottom: 8px;
        }
        .test-your-knowledge p {
            margin-bottom: 15px;
        }
        .check-button {
            display: inline-block;
            padding: 10px 20px;
            margin-top: 15px;
            color: #ffffff;
            background-color: #28a745;
            border-radius: 5px;
            text-decoration: none;
            cursor: pointer;
            border: none;
            font-size: 1em;
        }
        .faq-section {
            background-color: #fffbea;
        }
        .faq-section h3 {
            color: #ffcc00;
            font-size: 0.75em;
            margin-bottom: 5px;
            margin-top: 5px;
        }
        .faq-section h4 {
            color: #000;
            font-size: 0.9em;
            margin-top: 10px;
            margin-bottom: 8px;
        }
        canvas {
            border: 1px solid #ddd;
            display: block;
            margin: 0 auto;
            background-color: white;
        }
    </style>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <section id="section1">
<div class="image-placeholder">
            <img src="images/ball.png?height=300&width=600" alt="Image shows a 3D surface representing a cost function with a ball rolling down from a high point to a minimum, illustrating the concept of gradient descent as finding the lowest point by moving in the direction of steepest descent.">
        </div>
        <h1>Introduction to Gradient Descent</h1>
        <p>Imagine you're standing on a mountain in dense fog and want to reach the bottom as efficiently as possible. Without being able to see the entire landscape, how would you proceed? You might feel the ground around you and step in the direction where it slopes downward most steeply. After taking that step, you'd reassess and repeat until reaching the bottom. This intuitive approach mirrors how gradient descent works in machine learning—it helps algorithms find the minimum of a cost function by taking steps in the direction of steepest descent.</p>
        <div class="continue-button" onclick="showNextSection(2)">Continue</div>
    </section>

    <section id="section2">
        <h2>Why We Need Gradient Descent</h2>
        <p>When training machine learning models, we need to find the parameter values that minimize the error between our predictions and the actual data. For small datasets, we can often compute the optimal solution directly. However, as datasets grow larger, this direct approach becomes computationally expensive or even impossible.</p>
        <div class="continue-button" onclick="showNextSection(3)">Continue</div>
    </section>

    <section id="section3">
        <p>Gradient descent provides an efficient alternative by iteratively refining our parameter estimates. Instead of calculating the exact solution using all data at once, we make incremental improvements by moving in the direction that reduces the error most rapidly.</p>
        <div class="continue-button" onclick="showNextSection(4)">Continue</div>
    </section>

    <section id="section4">
        <p>This approach is particularly valuable in today's world where we often work with massive datasets containing millions or even billions of data points.</p>
<div class="continue-button" onclick="showNextSection(5)">Continue</div>
    </section>

    <section id="section5">
        <div class="why-it-matters">
            <h3>Why It Matters</h3>
            <p>Gradient descent makes machine learning practical for large-scale problems. Without efficient optimization methods like gradient descent, training complex models on large datasets would be computationally infeasible. It's the engine that powers most modern machine learning systems, from recommendation algorithms to image recognition.</p>
        </div>
<div class="continue-button" onclick="showNextSection(6)">Continue</div>
    </section>

    <section id="section6">
<div class="vocab-section">
            <h3>Build Your Vocab</h3>
            <h4 class="vocab-term">Cost Function</h4>
            <p>A function that measures how well a model's predictions match the actual data. In machine learning, we aim to minimize this function. Also called a loss function or objective function.</p>
        </div>
        <div class="continue-button" onclick="showNextSection(7)">Continue</div>
    </section>

    <section id="section7">
        <p>Let's understand how gradient descent works by breaking it down into simple steps.</p>
        
        <div class="continue-button" onclick="showNextSection(8)">Continue</div>
    </section>

    <section id="section8">
        <p>At its core, gradient descent is a simple algorithm with three key steps:</p>
        
        <ol>
            <li>Start with random parameter values.</li>
            <li>Calculate the gradient (direction of steepest increase) of the cost function.</li>
            <li>Update the parameters by moving in the opposite direction of the gradient.</li>
        </ol>
        <div class="continue-button" onclick="showNextSection(9)">Continue</div>
    </section>

    <section id="section9">
        <p>We repeat these steps until we reach a minimum or meet some stopping criteria. With each iteration, our parameters get closer to their optimal values, and our cost function decreases.</p>
        <div class="continue-button" onclick="showNextSection(10)">Continue</div>
    </section>

    <section id="section10">
        <p>The fundamental update rule for gradient descent is:</p>
        <p>\[ \beta = \beta - \alpha\nabla_\beta C(\beta) \]</p>
        <p>Let's break down what each part means:</p>
        <div class="continue-button" onclick="showNextSection(11)">Continue</div>
    </section>

    <section id="section11">
        <ul>
            <li>\( \beta \) represents our model parameters (coefficients in linear regression, weights in neural networks)</li>
            <li>\( C(\beta) \) is our cost function that measures prediction error</li>
            <li>\( \nabla_\beta C(\beta) \) is the gradient (vector of partial derivatives) of the cost function</li>
            <li>\( \alpha \) is the learning rate that controls our step size</li>
        </ul>
        <div class="continue-button" onclick="showNextSection(12)">Continue</div>
    </section>

    <section id="section12">
        <p>The gradient \( \nabla_\beta C(\beta) \) points in the direction of steepest increase of the cost function. Since we want to minimize the cost, we move in the opposite direction by subtracting the gradient (multiplied by the learning rate) from our current parameters.</p>
<div class="continue-button" onclick="showNextSection(13)">Continue</div>
    </section>

    <section id="section13">
        <div class="stop-and-think">
            <h3>Stop and Think</h3>
            <h4>Why do we multiply the gradient by a learning rate \( \alpha \) rather than just moving directly in the opposite direction of the gradient?</h4>
<p>Try to think of an answer yourself before you hit the reveal button.</p>
            <button class="reveal-button" onclick="revealAnswer('stop-and-think-1')">Reveal</button>
            <p id="stop-and-think-1" style="display: none;">The learning rate controls how big of a step we take. If it's too large, we might overshoot the minimum and potentially diverge. If it's too small, we'll take too many iterations to reach the minimum. It's like controlling how cautiously you step down the mountain: too boldly and you might fall past the valley; too timidly and your journey takes forever.</p>
        </div>
        <div class="continue-button" onclick="showNextSection(14)">Continue</div>
    </section>

    <section id="section14">
        <p>Let's see how this works with a simple example.</p>
        
        <div class="continue-button" onclick="showNextSection(15)">Continue</div>
    </section>

    <section id="section15">
        <p>Let's understand gradient descent through a concrete example. Imagine we have a simple cost function with a single parameter: \( C(\beta) = \beta^2 \). This is a parabola with its minimum at \( \beta = 0 \).</p>
</br>

<!-- Add this where you want to show just the parabola -->
<div class="interactive-placeholder">
    <canvas id="parabolaCanvas" width="700" height="400"></canvas>
    <script>
        // Immediately draw the parabola when this script runs
        (function() {
            // Get canvas and context
            const canvas = document.getElementById('parabolaCanvas');
            const ctx = canvas.getContext('2d');
            
            // Canvas dimensions and margins
            const margin = { top: 30, right: 30, bottom: 50, left: 60 };
            const width = canvas.width - margin.left - margin.right;
            const height = canvas.height - margin.top - margin.bottom;
            
            // Define the coordinate bounds for our visualization
            const xMin = -6;
            const xMax = 6;
            const yMin = -1;
            const yMax = 30;
            
            // Colors
            const colors = {
                blue: '#4C72B0',
                gray: '#E0E0E0',
                darkGray: '#444444'
            };
            
            // Functions to convert from data coordinates to canvas pixels
            function xToCanvas(x) {
                return margin.left + width * (x - xMin) / (xMax - xMin);
            }
            
            function yToCanvas(y) {
                return margin.top + height * (1 - (y - yMin) / (yMax - yMin));
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = colors.gray;
            ctx.lineWidth = 0.5;
            
            // Vertical grid lines
            for (let x = Math.floor(xMin); x <= Math.ceil(xMax); x++) {
                ctx.beginPath();
                ctx.moveTo(xToCanvas(x), yToCanvas(yMin));
                ctx.lineTo(xToCanvas(x), yToCanvas(yMax));
                ctx.stroke();
            }
            
            // Horizontal grid lines
            for (let y = Math.floor(yMin); y <= Math.ceil(yMax); y += 5) {
                ctx.beginPath();
                ctx.moveTo(xToCanvas(xMin), yToCanvas(y));
                ctx.lineTo(xToCanvas(xMax), yToCanvas(y));
                ctx.stroke();
            }
            
            // Draw axes
            ctx.strokeStyle = colors.darkGray;
            ctx.lineWidth = 2;
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            
            // X-axis
            ctx.beginPath();
            ctx.moveTo(xToCanvas(xMin), yToCanvas(0));
            ctx.lineTo(xToCanvas(xMax), yToCanvas(0));
            ctx.stroke();
            
            // X-axis ticks and labels
            ctx.fillStyle = colors.darkGray;
            for (let x = Math.floor(xMin); x <= Math.ceil(xMax); x += 2) {
                ctx.beginPath();
                ctx.moveTo(xToCanvas(x), yToCanvas(0) - 5);
                ctx.lineTo(xToCanvas(x), yToCanvas(0) + 5);
                ctx.stroke();
                
                ctx.fillText(x.toString(), xToCanvas(x), yToCanvas(0) + 20);
            }
            
            // X-axis label
            ctx.fillText('Parameter (β)', xToCanvas((xMax + xMin) / 2), yToCanvas(yMin) + 35);
            
            // Y-axis
            ctx.beginPath();
            ctx.moveTo(xToCanvas(0), yToCanvas(yMin));
            ctx.lineTo(xToCanvas(0), yToCanvas(yMax));
            ctx.stroke();
            
            // Y-axis ticks and labels
            ctx.textAlign = 'right';
            for (let y = 0; y <= yMax; y += 5) {
                ctx.beginPath();
                ctx.moveTo(xToCanvas(0) - 5, yToCanvas(y));
                ctx.lineTo(xToCanvas(0) + 5, yToCanvas(y));
                ctx.stroke();
                
                ctx.fillText(y.toString(), xToCanvas(0) - 10, yToCanvas(y) + 4);
            }
            
            // Y-axis label
            ctx.save();
            ctx.translate(xToCanvas(xMin) - 35, yToCanvas((yMax + yMin) / 2));
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText('Cost: C(β)', 0, 0);
            ctx.restore();
            
            // Draw the cost function curve
            ctx.strokeStyle = colors.blue;
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let x = xMin; x <= xMax; x += 0.1) {
                const y = x * x; // Our cost function is C(β) = β²
                
                if (x === xMin) {
                    ctx.moveTo(xToCanvas(x), yToCanvas(y));
                } else {
                    ctx.lineTo(xToCanvas(x), yToCanvas(y));
                }
            }
            
            ctx.stroke();
            
            // Label for the cost function
            ctx.fillStyle = colors.blue;
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Cost Function: C(β) = β²', xToCanvas(-5.5), yToCanvas(27));
        })();
    </script>
</div>
</br>
        <div class="continue-button" onclick="showNextSection(16)">Continue</div>
    </section>

    <section id="section16">
        <p>For this function, the gradient (derivative) is \( \nabla_\beta C(\beta) = 2\beta \). Let's start with \( \beta = 5 \) and use a learning rate \( \alpha = 0.1 \) to see how gradient descent finds the minimum.</p>
        <div class="continue-button" onclick="showNextSection(17)">Continue</div>
    </section>

    <section id="section17">
        <p><strong>Iteration 1:</strong></p>
        <ol>
            <li>Calculate gradient: \( \nabla_\beta C(\beta) = 2 \times 5 = 10 \)</li>
            <li>Update rule: \( \beta = 5 - 0.1 \times 10 = 5 - 1 = 4 \)</li>
        </ol>
        <p><strong>Iteration 2:</strong></p>
        <ol>
            <li>Calculate gradient: \( \nabla_\beta C(\beta) = 2 \times 4 = 8 \)</li>
            <li>Update rule: \( \beta = 4 - 0.1 \times 8 = 4 - 0.8 = 3.2 \)</li>
        </ol>
</br>
<p>Great, isn't it? Let's continue a few more iterations:</p>
        <div class="continue-button" onclick="showNextSection(18)">Continue</div>
    </section>

    <section id="section18">
        
        <p><strong>Iteration 3:</strong></p>
        <ol>
            <li>Gradient: \( 2 \times 3.2 = 6.4 \)</li>
            <li>Update: \( \beta = 3.2 - 0.1 \times 6.4 = 3.2 - 0.64 = 2.56 \)</li>
        </ol>
        <p><strong>Iteration 4:</strong></p>
        <ol>
            <li>Gradient: \( 2 \times 2.56 = 5.12 \)</li>
            <li>Update: \( \beta = 2.56 - 0.1 \times 5.12 = 2.56 - 0.512 = 2.048 \)</li>
        </ol>
</br>

<div class="interactive-placeholder">
    <canvas id="gdCanvas4Iterations" width="700" height="400"></canvas>
    <script>
        // Initialize first visualization when this section is shown
        document.getElementById('section18').addEventListener('transitionend', function(e) {
            if (e.target === this && this.style.opacity == 1) {
                initGradientDescent4Iterations('gdCanvas4Iterations');
            }
        });
    </script>
</div>
</br>

<p>As you can see, with each iteration, \( \beta \) gets closer to 0, which is the minimum of our function \( C(\beta) = \beta^2 \). The parameter updates gradually become smaller as we approach the minimum because the gradient becomes smaller (we're on a less steep part of the parabola).</p>
        <div class="continue-button" onclick="showNextSection(19)">Continue</div>
    </section>

    

<section id="section19">
    <p>If we would calculate a fifth iteration of gradient descent, what do you get for the updated parameter value?</p>
    
    <div class="quiz-options">
        <button class="quiz-button" onclick="checkQuizAnswer('correct')">1.6384</button>
        <button class="quiz-button" onclick="checkQuizAnswer('lower')">2</button>
        <button class="quiz-button" onclick="checkQuizAnswer('higher')">1.267</button>
    </div>
    
    <p id="quiz-feedback" style="display: none;"></p>
    
    <div class="continue-button" onclick="showNextSection(20)">Continue</div>
    
    <style>
        .quiz-options {
            margin: 20px 0;
        }
        .quiz-button {
            background-color: white;
            border: 2px solid black;
            border-radius: 25px;
            padding: 10px 30px;
            margin-right: 15px;
            margin-bottom: 15px;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.3s;
            display: inline-block;
        }
        .quiz-button:hover {
            background-color: #f0f0f0;
        }
        /* Removed colored feedback styles */
    </style>
    
    <script>
        function checkQuizAnswer(answer) {
            const feedbackDiv = document.getElementById('quiz-feedback');
            feedbackDiv.style.display = 'block';
            feedbackDiv.style.marginBottom = '20px';
            feedbackDiv.style.lineHeight = '1.6';
            feedbackDiv.style.color = '#444';
            
            if (answer === 'correct') {
                feedbackDiv.innerHTML = "Exactly, well done! After iteration 4, β = 2.048. In iteration 5, the gradient is 2 × 2.048 = 4.096, so the update is 2.048 - 0.1 × 4.096 = 1.6384.";
            } else if (answer === 'lower') {
                feedbackDiv.innerHTML = "That's too high. After iteration 4, β = 2.048. The gradient at this point is 2 × 2.048 = 4.096, so the update should be 2.048 - 0.1 × 4.096 = 1.6384.";
            } else if (answer === 'higher') {
                feedbackDiv.innerHTML = "That's too low. After iteration 4, β = 2.048. The gradient at this point is 2 × 2.048 = 4.096, so the update should be 2.048 - 0.1 × 4.096 = 1.6384.";
            }
        }
    </script>
</section>

    <section id="section20">
        <p>If we continued this process, \( \beta \) would eventually converge to 0, which is exactly what we want! This illustrates how gradient descent iteratively finds the minimum of a function.</p>
</br>

        <div class="interactive-placeholder">
    <canvas id="gdCanvasUntilMin" width="700" height="400"></canvas>
    <script>
        // Initialize second visualization when this section is shown
        document.getElementById('section20').addEventListener('transitionend', function(e) {
            if (e.target === this && this.style.opacity == 1) {
                initGradientDescentUntilMin('gdCanvasUntilMin');
            }
        });
    </script>
</div>
</br>

      <div class="continue-button" onclick="showNextSection(21)">Continue</div>
    </section>

    <section id="section21">
        <p>While this example used a simple function with one parameter, the same principles apply to more complex cost functions with multiple parameters, like those found in real machine learning problems.</p>
<div class="continue-button" onclick="showNextSection(22)">Continue</div>
    </section>

    
    <section id="section22">
<h2>The Learning Rate</h2>
        <p>The learning rate \( \alpha \) is a critical hyperparameter in gradient descent. It controls how big of a step we take in the direction of the negative gradient.</p>
        <div class="continue-button" onclick="showNextSection(23)">Continue</div>
    </section>

    <section id="section23">
        <p>Choosing an appropriate learning rate is crucial for successful optimization:</p>
        <div class="continue-button" onclick="showNextSection(24)">Continue</div>
    </section>

    <section id="section24">
        <ul>
            <li>If \( \alpha \) is too small: Gradient descent will take tiny steps and converge very slowly, requiring many iterations.</li>
            <li>If \( \alpha \) is too large: Gradient descent might overshoot the minimum, bounce around, or even diverge completely.</li>
        </ul>
        
        <div class="continue-button" onclick="showNextSection(25)">Continue</div>
    </section>

    <section id="section25">
        <p>Think of the learning rate as controlling how cautiously you step down the mountain. With tiny steps, you'll eventually reach the bottom but might take all day. With giant leaps, you might jump right past the valley or even up the opposite slope!</p>
        <div class="continue-button" onclick="showNextSection(26)">Continue</div>
    </section>

    <section id="section26">
        <p>In practice, finding a good learning rate often involves experimentation. Some advanced techniques even adjust the learning rate during training based on how the optimization is progressing.</p>
<div class="continue-button" onclick="showNextSection(27)">Continue</div>
    </section>

    <section id="section27">
        <div class="vocab-section">
            <h3>Build Your Vocab</h3>
            <h4 class="vocab-term">Hyperparameter</h4>
            <p>A parameter that is set before the learning process begins, rather than learned during training. The learning rate is a hyperparameter that controls how much the model parameters change in response to the estimated error.</p>
        </div>
        <div class="continue-button" onclick="showNextSection(28)">Continue</div>
    </section>

    <section id="section28">
        <p>Let's see what happens with different learning rates for our simple example \( C(\beta) = \beta^2 \) starting from \( \beta = 5 \). Let's start with a too small learning rate.</p>
</br>

        <div class="interactive-placeholder">
    <canvas id="learningRateComparison1Canvas" width="800" height="500"></canvas>
    <script>
        // Define the visualization function but don't start it immediately
        function initLearningRateComparison1() {
            // Get canvas and context
            const canvas = document.getElementById('learningRateComparison1Canvas');
            const ctx = canvas.getContext('2d');
            
            // Parameters for gradient descent
            const initialBeta = 5;
            const learningRates = [0.01]; // small, good, large
            const numIterations = 50; // More iterations to show differences
            const maxFrames = 100; // More frames for slower animation
            
            // Calculate gradient descent paths for different learning rates
            function calculateGradientDescentPaths() {
                const allPaths = [];
                
                for (const alpha of learningRates) {
                    const betaValues = [initialBeta];
                    const costValues = [initialBeta * initialBeta];
                    
                    let beta = initialBeta;
                    for (let i = 0; i < numIterations; i++) {
                        const gradient = 2 * beta; // Derivative of β²
                        beta = beta - alpha * gradient;
                        
                        // For large learning rates, check for divergence
                        if (Math.abs(beta) > 10) {
                            break; // Stop if diverging
                        }
                        
                        betaValues.push(beta);
                        costValues.push(beta * beta);
                    }
                    
                    allPaths.push({ betaValues, costValues });
                }
                
                return allPaths;
            }
            
            // Calculate all paths
            const allPaths = calculateGradientDescentPaths();
            
            // Canvas dimensions and margins
            const margin = { top: 40, right: 140, bottom: 60, left: 70 };
            const width = canvas.width - margin.left - margin.right;
            const height = canvas.height - margin.top - margin.bottom;
            
            // Define the coordinate bounds for our visualization
            const xMin = -6;
            const xMax = 6;
            const yMin = -1;
            const yMax = 30;
            
            // Colors
            const colors = {
                blue: '#4C72B0',
                red: '#C44E52',
                green: '#55A868',
                purple: '#8172B3',
                orange: '#CCB974',
                gray: '#E0E0E0',
                darkGray: '#444444'
            };
            
            // Path colors
            const pathColors = [colors.purple, colors.green, colors.red];
            
            // Functions to convert from data coordinates to canvas pixels
            function xToCanvas(x) {
                return margin.left + width * (x - xMin) / (xMax - xMin);
            }
            
            function yToCanvas(y) {
                return margin.top + height * (1 - (y - yMin) / (yMax - yMin));
            }
            
            // Current frame for animation
            let currentFrame = 0;
            let animationId = null;
            
            // Draw the visualization
            function draw() {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw grid
                drawGrid();
                
                // Draw axes
                drawAxes();
                
                // Draw the parabola (cost function)
                drawCostFunction();
                
                // Draw gradient descent paths
                drawPaths();
                
                // Draw legend
                drawLegend();
            }
            
            // Draw a light grid
            function drawGrid() {
                ctx.strokeStyle = colors.gray;
                ctx.lineWidth = 0.5;
                
                // Vertical grid lines
                for (let x = Math.floor(xMin); x <= Math.ceil(xMax); x++) {
                    ctx.beginPath();
                    ctx.moveTo(xToCanvas(x), yToCanvas(yMin));
                    ctx.lineTo(xToCanvas(x), yToCanvas(yMax));
                    ctx.stroke();
                }
                
                // Horizontal grid lines
                for (let y = Math.floor(yMin); y <= Math.ceil(yMax); y += 5) {
                    ctx.beginPath();
                    ctx.moveTo(xToCanvas(xMin), yToCanvas(y));
                    ctx.lineTo(xToCanvas(xMax), yToCanvas(y));
                    ctx.stroke();
                }
            }
            
            // Draw x and y axes
            function drawAxes() {
                ctx.strokeStyle = colors.darkGray;
                ctx.lineWidth = 2;
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                
                // X-axis
                ctx.beginPath();
                ctx.moveTo(xToCanvas(xMin), yToCanvas(0));
                ctx.lineTo(xToCanvas(xMax), yToCanvas(0));
                ctx.stroke();
                
                // X-axis ticks and labels
                ctx.fillStyle = colors.darkGray;
                for (let x = Math.floor(xMin); x <= Math.ceil(xMax); x += 2) {
                    ctx.beginPath();
                    ctx.moveTo(xToCanvas(x), yToCanvas(0) - 5);
                    ctx.lineTo(xToCanvas(x), yToCanvas(0) + 5);
                    ctx.stroke();
                    
                    ctx.fillText(x.toString(), xToCanvas(x), yToCanvas(0) + 20);
                }
                
                // X-axis label
                ctx.fillText('Parameter (β)', xToCanvas((xMax + xMin) / 2), yToCanvas(yMin) + 35);
                
                // Y-axis
                ctx.beginPath();
                ctx.moveTo(xToCanvas(0), yToCanvas(yMin));
                ctx.lineTo(xToCanvas(0), yToCanvas(yMax));
                ctx.stroke();
                
                // Y-axis ticks and labels
                ctx.textAlign = 'right';
                for (let y = 0; y <= yMax; y += 5) {
                    ctx.beginPath();
                    ctx.moveTo(xToCanvas(0) - 5, yToCanvas(y));
                    ctx.lineTo(xToCanvas(0) + 5, yToCanvas(y));
                    ctx.stroke();
                    
                    ctx.fillText(y.toString(), xToCanvas(0) - 10, yToCanvas(y) + 4);
                }
                
                // Y-axis label
                ctx.save();
                ctx.translate(xToCanvas(xMin) - 35, yToCanvas((yMax + yMin) / 2));
                ctx.rotate(-Math.PI / 2);
                ctx.textAlign = 'center';
                ctx.fillText('Cost: C(β)', 0, 0);
                ctx.restore();
            }
            
            // Draw the cost function curve
            function drawCostFunction() {
                ctx.strokeStyle = colors.blue;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let x = xMin; x <= xMax; x += 0.1) {
                    const y = x * x; // Our cost function is C(β) = β²
                    
                    if (x === xMin) {
                        ctx.moveTo(xToCanvas(x), yToCanvas(y));
                    } else {
                        ctx.lineTo(xToCanvas(x), yToCanvas(y));
                    }
                }
                
                ctx.stroke();
                
                // Label for the cost function
                ctx.fillStyle = colors.blue;
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('Cost Function: C(β) = β²', xToCanvas(-5.5), yToCanvas(27));
            }
            
            // Draw the gradient descent paths
            function drawPaths() {
                for (let pathIdx = 0; pathIdx < allPaths.length; pathIdx++) {
                    const { betaValues, costValues } = allPaths[pathIdx];
                    const color = pathColors[pathIdx];
                    
                    // Calculate number of points to show at current animation frame
                    const maxPoints = Math.min(
                        betaValues.length,
                        Math.ceil((currentFrame / maxFrames) * betaValues.length)
                    );
                    
                    // Path line
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    for (let i = 0; i < maxPoints; i++) {
                        const x = betaValues[i];
                        const y = costValues[i];
                        
                        if (i === 0) {
                            ctx.moveTo(xToCanvas(x), yToCanvas(y));
                        } else {
                            ctx.lineTo(xToCanvas(x), yToCanvas(y));
                        }
                    }
                    
                    ctx.stroke();
                    
                    // Draw points
                    for (let i = 0; i < maxPoints; i++) {
                        const x = betaValues[i];
                        const y = costValues[i];
                        
                        // Draw point
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(xToCanvas(x), yToCanvas(y), 4, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // Draw label for first and last point of each path
                        if (i === 0 || i === maxPoints - 1) {
                            ctx.fillStyle = colors.darkGray;
                            ctx.font = '10px Arial';
                            ctx.textAlign = 'left';
                            ctx.fillText(`β=${x.toFixed(2)}`, xToCanvas(x) + 10, yToCanvas(y) - 5);
                        }
                    }
                }
            }
            
            // Draw legend
            function drawLegend() {
                const legendX = xToCanvas(xMax) + 10;
                const legendY = margin.top + 20;
                const lineLength = 20;
                const spacing = 25;
                
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'left';
                ctx.fillStyle = colors.darkGray;
                ctx.fillText('Learning Rates:', legendX, legendY);
                
                for (let i = 0; i < learningRates.length; i++) {
                    const y = legendY + (i + 1) * spacing;
                    
                    // Draw line
                    ctx.strokeStyle = pathColors[i];
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(legendX, y);
                    ctx.lineTo(legendX + lineLength, y);
                    ctx.stroke();
                    
                    // Draw point
                    ctx.fillStyle = pathColors[i];
                    ctx.beginPath();
                    ctx.arc(legendX + lineLength/2, y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Draw label
                    ctx.fillStyle = colors.darkGray;
                    ctx.textAlign = 'left';
                    
                    let label;
                    if (i === 0) {
                        label = `α=${learningRates[i]} (too small)`;
                    } else if (i === 1) {
                        label = `α=${learningRates[i]} (good)`;
                    } else {
                        label = `α=${learningRates[i]} (too large)`;
                    }
                    
                    ctx.fillText(label, legendX + lineLength + 5, y + 4);
                }
            }
            
            // Animation function
            function animate() {
                currentFrame = (currentFrame + 1) % (maxFrames + 30); // Extra frames for pause
                
                // Draw the current frame
                draw();
                
                // Continue animation
                animationId = setTimeout(animate, 200); // Slower animation speed (200ms between frames)
            }
            
            // Initial draw to show the canvas with the parabola
            draw();
            
            // Start animation
            animate();
        }
        
        // Wait for section 28 to be displayed before starting the animation
        document.addEventListener('DOMContentLoaded', function() {
            // First draw the initial state
            const canvas = document.getElementById('learningRateComparison1Canvas');
            const ctx = canvas.getContext('2d');
            ctx.font = '14px Arial';
            ctx.fillStyle = '#444444';
            ctx.textAlign = 'center';
            ctx.fillText('Visualization will start when this section is displayed', canvas.width/2, canvas.height/2);
            
            // Add an event listener to section 28
            const section28 = document.getElementById('section28');
            if (section28) {
                section28.addEventListener('transitionend', function(e) {
                    if (e.target === this && this.style.opacity == 1) {
                        // Section 28 is now visible, start the animation
                        initLearningRateComparison1();
                    }
                });
            }
        });
    </script>
</div>
</br>

<p>As you can see, Gradient descent will take tiny steps and converge very slowly, requiring many iterations.</p>
<div class="continue-button" onclick="showNextSection(29)">Continue</div>
    </section>

    <section id="section29">
<p>Let's see what happens with a good learning rate.</p>
</br>

      <div class="interactive-placeholder">
    <canvas id="learningRateComparison2Canvas" width="800" height="500"></canvas>
    <script>
        // Define the visualization function but don't start it immediately
        function initLearningRateComparison2() {
            // Get canvas and context
            const canvas = document.getElementById('learningRateComparison2Canvas');
            const ctx = canvas.getContext('2d');
            
            // Parameters for gradient descent
            const initialBeta = 5;
            const learningRates = [0.1]; // small, good, large
            const numIterations = 50; // More iterations to show differences
            const maxFrames = 100; // More frames for slower animation
            
            // Calculate gradient descent paths for different learning rates
            function calculateGradientDescentPaths() {
                const allPaths = [];
                
                for (const alpha of learningRates) {
                    const betaValues = [initialBeta];
                    const costValues = [initialBeta * initialBeta];
                    
                    let beta = initialBeta;
                    for (let i = 0; i < numIterations; i++) {
                        const gradient = 2 * beta; // Derivative of β²
                        beta = beta - alpha * gradient;
                        
                        // For large learning rates, check for divergence
                        if (Math.abs(beta) > 10) {
                            break; // Stop if diverging
                        }
                        
                        betaValues.push(beta);
                        costValues.push(beta * beta);
                    }
                    
                    allPaths.push({ betaValues, costValues });
                }
                
                return allPaths;
            }
            
            // Calculate all paths
            const allPaths = calculateGradientDescentPaths();
            
            // Canvas dimensions and margins
            const margin = { top: 40, right: 140, bottom: 60, left: 70 };
            const width = canvas.width - margin.left - margin.right;
            const height = canvas.height - margin.top - margin.bottom;
            
            // Define the coordinate bounds for our visualization
            const xMin = -6;
            const xMax = 6;
            const yMin = -1;
            const yMax = 30;
            
            // Colors
            const colors = {
                blue: '#4C72B0',
                red: '#C44E52',
                green: '#55A868',
                purple: '#8172B3',
                orange: '#CCB974',
                gray: '#E0E0E0',
                darkGray: '#444444'
            };
            
            // Path colors
            const pathColors = [colors.purple, colors.green, colors.red];
            
            // Functions to convert from data coordinates to canvas pixels
            function xToCanvas(x) {
                return margin.left + width * (x - xMin) / (xMax - xMin);
            }
            
            function yToCanvas(y) {
                return margin.top + height * (1 - (y - yMin) / (yMax - yMin));
            }
            
            // Current frame for animation
            let currentFrame = 0;
            let animationId = null;
            
            // Draw the visualization
            function draw() {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw grid
                drawGrid();
                
                // Draw axes
                drawAxes();
                
                // Draw the parabola (cost function)
                drawCostFunction();
                
                // Draw gradient descent paths
                drawPaths();
                
                // Draw legend
                drawLegend();
            }
            
            // Draw a light grid
            function drawGrid() {
                ctx.strokeStyle = colors.gray;
                ctx.lineWidth = 0.5;
                
                // Vertical grid lines
                for (let x = Math.floor(xMin); x <= Math.ceil(xMax); x++) {
                    ctx.beginPath();
                    ctx.moveTo(xToCanvas(x), yToCanvas(yMin));
                    ctx.lineTo(xToCanvas(x), yToCanvas(yMax));
                    ctx.stroke();
                }
                
                // Horizontal grid lines
                for (let y = Math.floor(yMin); y <= Math.ceil(yMax); y += 5) {
                    ctx.beginPath();
                    ctx.moveTo(xToCanvas(xMin), yToCanvas(y));
                    ctx.lineTo(xToCanvas(xMax), yToCanvas(y));
                    ctx.stroke();
                }
            }
            
            // Draw x and y axes
            function drawAxes() {
                ctx.strokeStyle = colors.darkGray;
                ctx.lineWidth = 2;
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                
                // X-axis
                ctx.beginPath();
                ctx.moveTo(xToCanvas(xMin), yToCanvas(0));
                ctx.lineTo(xToCanvas(xMax), yToCanvas(0));
                ctx.stroke();
                
                // X-axis ticks and labels
                ctx.fillStyle = colors.darkGray;
                for (let x = Math.floor(xMin); x <= Math.ceil(xMax); x += 2) {
                    ctx.beginPath();
                    ctx.moveTo(xToCanvas(x), yToCanvas(0) - 5);
                    ctx.lineTo(xToCanvas(x), yToCanvas(0) + 5);
                    ctx.stroke();
                    
                    ctx.fillText(x.toString(), xToCanvas(x), yToCanvas(0) + 20);
                }
                
                // X-axis label
                ctx.fillText('Parameter (β)', xToCanvas((xMax + xMin) / 2), yToCanvas(yMin) + 35);
                
                // Y-axis
                ctx.beginPath();
                ctx.moveTo(xToCanvas(0), yToCanvas(yMin));
                ctx.lineTo(xToCanvas(0), yToCanvas(yMax));
                ctx.stroke();
                
                // Y-axis ticks and labels
                ctx.textAlign = 'right';
                for (let y = 0; y <= yMax; y += 5) {
                    ctx.beginPath();
                    ctx.moveTo(xToCanvas(0) - 5, yToCanvas(y));
                    ctx.lineTo(xToCanvas(0) + 5, yToCanvas(y));
                    ctx.stroke();
                    
                    ctx.fillText(y.toString(), xToCanvas(0) - 10, yToCanvas(y) + 4);
                }
                
                // Y-axis label
                ctx.save();
                ctx.translate(xToCanvas(xMin) - 35, yToCanvas((yMax + yMin) / 2));
                ctx.rotate(-Math.PI / 2);
                ctx.textAlign = 'center';
                ctx.fillText('Cost: C(β)', 0, 0);
                ctx.restore();
            }
            
            // Draw the cost function curve
            function drawCostFunction() {
                ctx.strokeStyle = colors.blue;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let x = xMin; x <= xMax; x += 0.1) {
                    const y = x * x; // Our cost function is C(β) = β²
                    
                    if (x === xMin) {
                        ctx.moveTo(xToCanvas(x), yToCanvas(y));
                    } else {
                        ctx.lineTo(xToCanvas(x), yToCanvas(y));
                    }
                }
                
                ctx.stroke();
                
                // Label for the cost function
                ctx.fillStyle = colors.blue;
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('Cost Function: C(β) = β²', xToCanvas(-5.5), yToCanvas(27));
            }
            
            // Draw the gradient descent paths
            function drawPaths() {
                for (let pathIdx = 0; pathIdx < allPaths.length; pathIdx++) {
                    const { betaValues, costValues } = allPaths[pathIdx];
                    const color = pathColors[pathIdx];
                    
                    // Calculate number of points to show at current animation frame
                    const maxPoints = Math.min(
                        betaValues.length,
                        Math.ceil((currentFrame / maxFrames) * betaValues.length)
                    );
                    
                    // Path line
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    for (let i = 0; i < maxPoints; i++) {
                        const x = betaValues[i];
                        const y = costValues[i];
                        
                        if (i === 0) {
                            ctx.moveTo(xToCanvas(x), yToCanvas(y));
                        } else {
                            ctx.lineTo(xToCanvas(x), yToCanvas(y));
                        }
                    }
                    
                    ctx.stroke();
                    
                    // Draw points
                    for (let i = 0; i < maxPoints; i++) {
                        const x = betaValues[i];
                        const y = costValues[i];
                        
                        // Draw point
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(xToCanvas(x), yToCanvas(y), 4, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // Draw label for first and last point of each path
                        if (i === 0 || i === maxPoints - 1) {
                            ctx.fillStyle = colors.darkGray;
                            ctx.font = '10px Arial';
                            ctx.textAlign = 'left';
                            ctx.fillText(`β=${x.toFixed(2)}`, xToCanvas(x) + 10, yToCanvas(y) - 5);
                        }
                    }
                }
            }
            
            // Draw legend
            function drawLegend() {
                const legendX = xToCanvas(xMax) + 10;
                const legendY = margin.top + 20;
                const lineLength = 20;
                const spacing = 25;
                
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'left';
                ctx.fillStyle = colors.darkGray;
                ctx.fillText('Learning Rates:', legendX, legendY);
                
                for (let i = 0; i < learningRates.length; i++) {
                    const y = legendY + (i + 1) * spacing;
                    
                    // Draw line
                    ctx.strokeStyle = pathColors[i];
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(legendX, y);
                    ctx.lineTo(legendX + lineLength, y);
                    ctx.stroke();
                    
                    // Draw point
                    ctx.fillStyle = pathColors[i];
                    ctx.beginPath();
                    ctx.arc(legendX + lineLength/2, y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Draw label
                    ctx.fillStyle = colors.darkGray;
                    ctx.textAlign = 'left';
                    
                    let label;
                    if (i === 0) {
                        label = `α=${learningRates[i]} (good)`;
                    } else if (i === 1) {
                        label = `α=${learningRates[i]} (good)`;
                    } else {
                        label = `α=${learningRates[i]} (too large)`;
                    }
                    
                    ctx.fillText(label, legendX + lineLength + 5, y + 4);
                }
            }
            
            // Animation function
            function animate() {
                currentFrame = (currentFrame + 1) % (maxFrames + 30); // Extra frames for pause
                
                // Draw the current frame
                draw();
                
                // Continue animation
                animationId = setTimeout(animate, 200); // Slower animation speed (200ms between frames)
            }
            
            // Initial draw to show the canvas with the parabola
            draw();
            
            // Start animation
            animate();
        }
        
        // Wait for section 29 to be displayed before starting the animation
        document.addEventListener('DOMContentLoaded', function() {
            // First draw the initial state
            const canvas = document.getElementById('learningRateComparison2Canvas');
            const ctx = canvas.getContext('2d');
            ctx.font = '14px Arial';
            ctx.fillStyle = '#444444';
            ctx.textAlign = 'center';
            ctx.fillText('Visualization will start when this section is displayed', canvas.width/2, canvas.height/2);
            
            // Add an event listener to section 29
            const section29 = document.getElementById('section29');
            if (section29) {
                section29.addEventListener('transitionend', function(e) {
                    if (e.target === this && this.style.opacity == 1) {
                        // Section 29 is now visible, start the animation
                        initLearningRateComparison2();
                    }
                });
            }
        });
    </script>
</div>
</br>

<p>Gradient Descent converges to 0, which is exactly what we want!</p>
<div class="continue-button" onclick="showNextSection(30)">Continue</div>
    </section>

    <section id="section30">
<p>Now let's see what happens with a too large learning rate.</p>
</br>

      <div class="interactive-placeholder">
    <canvas id="learningRateComparison3Canvas" width="800" height="500"></canvas>
    <script>
        // Define the visualization function but don't start it immediately
        function initLearningRateComparison3() {
            // Get canvas and context
            const canvas = document.getElementById('learningRateComparison3Canvas');
            const ctx = canvas.getContext('2d');
            
            // Parameters for gradient descent
            const initialBeta = 5;
            const learningRates = [0.8]; // small, good, large
            const numIterations = 50; // More iterations to show differences
            const maxFrames = 100; // More frames for slower animation
            
            // Calculate gradient descent paths for different learning rates
            function calculateGradientDescentPaths() {
                const allPaths = [];
                
                for (const alpha of learningRates) {
                    const betaValues = [initialBeta];
                    const costValues = [initialBeta * initialBeta];
                    
                    let beta = initialBeta;
                    for (let i = 0; i < numIterations; i++) {
                        const gradient = 2 * beta; // Derivative of β²
                        beta = beta - alpha * gradient;
                        
                        // For large learning rates, check for divergence
                        if (Math.abs(beta) > 10) {
                            break; // Stop if diverging
                        }
                        
                        betaValues.push(beta);
                        costValues.push(beta * beta);
                    }
                    
                    allPaths.push({ betaValues, costValues });
                }
                
                return allPaths;
            }
            
            // Calculate all paths
            const allPaths = calculateGradientDescentPaths();
            
            // Canvas dimensions and margins
            const margin = { top: 40, right: 140, bottom: 60, left: 70 };
            const width = canvas.width - margin.left - margin.right;
            const height = canvas.height - margin.top - margin.bottom;
            
            // Define the coordinate bounds for our visualization
            const xMin = -6;
            const xMax = 6;
            const yMin = -1;
            const yMax = 30;
            
            // Colors
            const colors = {
                blue: '#4C72B0',
                red: '#C44E52',
                green: '#55A868',
                purple: '#8172B3',
                orange: '#CCB974',
                gray: '#E0E0E0',
                darkGray: '#444444'
            };
            
            // Path colors
            const pathColors = [colors.purple, colors.green, colors.red];
            
            // Functions to convert from data coordinates to canvas pixels
            function xToCanvas(x) {
                return margin.left + width * (x - xMin) / (xMax - xMin);
            }
            
            function yToCanvas(y) {
                return margin.top + height * (1 - (y - yMin) / (yMax - yMin));
            }
            
            // Current frame for animation
            let currentFrame = 0;
            let animationId = null;
            
            // Draw the visualization
            function draw() {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw grid
                drawGrid();
                
                // Draw axes
                drawAxes();
                
                // Draw the parabola (cost function)
                drawCostFunction();
                
                // Draw gradient descent paths
                drawPaths();
                
                // Draw legend
                drawLegend();
            }
            
            // Draw a light grid
            function drawGrid() {
                ctx.strokeStyle = colors.gray;
                ctx.lineWidth = 0.5;
                
                // Vertical grid lines
                for (let x = Math.floor(xMin); x <= Math.ceil(xMax); x++) {
                    ctx.beginPath();
                    ctx.moveTo(xToCanvas(x), yToCanvas(yMin));
                    ctx.lineTo(xToCanvas(x), yToCanvas(yMax));
                    ctx.stroke();
                }
                
                // Horizontal grid lines
                for (let y = Math.floor(yMin); y <= Math.ceil(yMax); y += 5) {
                    ctx.beginPath();
                    ctx.moveTo(xToCanvas(xMin), yToCanvas(y));
                    ctx.lineTo(xToCanvas(xMax), yToCanvas(y));
                    ctx.stroke();
                }
            }
            
            // Draw x and y axes
            function drawAxes() {
                ctx.strokeStyle = colors.darkGray;
                ctx.lineWidth = 2;
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                
                // X-axis
                ctx.beginPath();
                ctx.moveTo(xToCanvas(xMin), yToCanvas(0));
                ctx.lineTo(xToCanvas(xMax), yToCanvas(0));
                ctx.stroke();
                
                // X-axis ticks and labels
                ctx.fillStyle = colors.darkGray;
                for (let x = Math.floor(xMin); x <= Math.ceil(xMax); x += 2) {
                    ctx.beginPath();
                    ctx.moveTo(xToCanvas(x), yToCanvas(0) - 5);
                    ctx.lineTo(xToCanvas(x), yToCanvas(0) + 5);
                    ctx.stroke();
                    
                    ctx.fillText(x.toString(), xToCanvas(x), yToCanvas(0) + 20);
                }
                
                // X-axis label
                ctx.fillText('Parameter (β)', xToCanvas((xMax + xMin) / 2), yToCanvas(yMin) + 35);
                
                // Y-axis
                ctx.beginPath();
                ctx.moveTo(xToCanvas(0), yToCanvas(yMin));
                ctx.lineTo(xToCanvas(0), yToCanvas(yMax));
                ctx.stroke();
                
                // Y-axis ticks and labels
                ctx.textAlign = 'right';
                for (let y = 0; y <= yMax; y += 5) {
                    ctx.beginPath();
                    ctx.moveTo(xToCanvas(0) - 5, yToCanvas(y));
                    ctx.lineTo(xToCanvas(0) + 5, yToCanvas(y));
                    ctx.stroke();
                    
                    ctx.fillText(y.toString(), xToCanvas(0) - 10, yToCanvas(y) + 4);
                }
                
                // Y-axis label
                ctx.save();
                ctx.translate(xToCanvas(xMin) - 35, yToCanvas((yMax + yMin) / 2));
                ctx.rotate(-Math.PI / 2);
                ctx.textAlign = 'center';
                ctx.fillText('Cost: C(β)', 0, 0);
                ctx.restore();
            }
            
            // Draw the cost function curve
            function drawCostFunction() {
                ctx.strokeStyle = colors.blue;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let x = xMin; x <= xMax; x += 0.1) {
                    const y = x * x; // Our cost function is C(β) = β²
                    
                    if (x === xMin) {
                        ctx.moveTo(xToCanvas(x), yToCanvas(y));
                    } else {
                        ctx.lineTo(xToCanvas(x), yToCanvas(y));
                    }
                }
                
                ctx.stroke();
                
                // Label for the cost function
                ctx.fillStyle = colors.blue;
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('Cost Function: C(β) = β²', xToCanvas(-5.5), yToCanvas(27));
            }
            
            // Draw the gradient descent paths
            function drawPaths() {
                for (let pathIdx = 0; pathIdx < allPaths.length; pathIdx++) {
                    const { betaValues, costValues } = allPaths[pathIdx];
                    const color = pathColors[pathIdx];
                    
                    // Calculate number of points to show at current animation frame
                    const maxPoints = Math.min(
                        betaValues.length,
                        Math.ceil((currentFrame / maxFrames) * betaValues.length)
                    );
                    
                    // Path line
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    for (let i = 0; i < maxPoints; i++) {
                        const x = betaValues[i];
                        const y = costValues[i];
                        
                        if (i === 0) {
                            ctx.moveTo(xToCanvas(x), yToCanvas(y));
                        } else {
                            ctx.lineTo(xToCanvas(x), yToCanvas(y));
                        }
                    }
                    
                    ctx.stroke();
                    
                    // Draw points
                    for (let i = 0; i < maxPoints; i++) {
                        const x = betaValues[i];
                        const y = costValues[i];
                        
                        // Draw point
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(xToCanvas(x), yToCanvas(y), 4, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // Draw label for first and last point of each path
                        if (i === 0 || i === maxPoints - 1) {
                            ctx.fillStyle = colors.darkGray;
                            ctx.font = '10px Arial';
                            ctx.textAlign = 'left';
                            ctx.fillText(`β=${x.toFixed(2)}`, xToCanvas(x) + 10, yToCanvas(y) - 5);
                        }
                    }
                }
            }
            
            // Draw legend
            function drawLegend() {
                const legendX = xToCanvas(xMax) + 10;
                const legendY = margin.top + 20;
                const lineLength = 20;
                const spacing = 25;
                
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'left';
                ctx.fillStyle = colors.darkGray;
                ctx.fillText('Learning Rates:', legendX, legendY);
                
                for (let i = 0; i < learningRates.length; i++) {
                    const y = legendY + (i + 1) * spacing;
                    
                    // Draw line
                    ctx.strokeStyle = pathColors[i];
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(legendX, y);
                    ctx.lineTo(legendX + lineLength, y);
                    ctx.stroke();
                    
                    // Draw point
                    ctx.fillStyle = pathColors[i];
                    ctx.beginPath();
                    ctx.arc(legendX + lineLength/2, y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Draw label
                    ctx.fillStyle = colors.darkGray;
                    ctx.textAlign = 'left';
                    
                    let label;
                    if (i === 0) {
                        label = `α=${learningRates[i]} (too large)`;
                    } else if (i === 1) {
                        label = `α=${learningRates[i]} (good)`;
                    } else {
                        label = `α=${learningRates[i]} (too large)`;
                    }
                    
                    ctx.fillText(label, legendX + lineLength + 5, y + 4);
                }
            }
            
            // Animation function
            function animate() {
                currentFrame = (currentFrame + 1) % (maxFrames + 30); // Extra frames for pause
                
                // Draw the current frame
                draw();
                
                // Continue animation
                animationId = setTimeout(animate, 200); // Slower animation speed (200ms between frames)
            }
            
            // Initial draw to show the canvas with the parabola
            draw();
            
            // Start animation
            animate();
        }
        
        // Wait for section 30 to be displayed before starting the animation
        document.addEventListener('DOMContentLoaded', function() {
            // First draw the initial state
            const canvas = document.getElementById('learningRateComparison3Canvas');
            const ctx = canvas.getContext('2d');
            ctx.font = '14px Arial';
            ctx.fillStyle = '#444444';
            ctx.textAlign = 'center';
            ctx.fillText('Visualization will start when this section is displayed', canvas.width/2, canvas.height/2);
            
            // Add an event listener to section 30
            const section30 = document.getElementById('section30');
            if (section30) {
                section30.addEventListener('transitionend', function(e) {
                    if (e.target === this && this.style.opacity == 1) {
                        // Section 30 is now visible, start the animation
                        initLearningRateComparison3();
                    }
                });
            }
        });
    </script>
</div>
</br>

        <p>The Gradient descent overshoots the minimum and bounces around.</p>

        <div class="continue-button" onclick="showNextSection(31)">Continue</div>
    </section>

    <section id="section31">
        <h2>Real-World Applications</h2>
        <p>Gradient descent is the workhorse behind most modern machine learning algorithms. Let's look at a few common applications:</p>
        <div class="continue-button" onclick="showNextSection(32)">Continue</div>
    </section>

    <section id="section32">
        <ol>
            <li>Linear Regression: Finding the line of best fit for a dataset by minimizing the sum of squared errors.</li>
            <li>Logistic Regression: Training classifiers for tasks like spam detection or disease diagnosis.</li>
            <li>Neural Networks: Training deep learning models for image recognition, natural language processing, and more.</li>
            <li>Recommendation Systems: Optimizing user-item interaction predictions on platforms like Netflix or Amazon.</li>
        </ol>
        <div class="continue-button" onclick="showNextSection(33)">Continue</div>
    </section>

    <section id="section33">
        <p>While the specific cost functions vary, the core idea remains the same: iteratively adjust parameters to minimize an error function.</p>
        <div class="continue-button" onclick="showNextSection(34)">Continue</div>
    </section>

    

    <section id="section34">
        <div class="stop-and-think">
            <h3>Stop and Think</h3>
            <h4>Thinking about the mountain analogy we started with, what might represent a 'local minimum' that isn't the lowest possible point? What challenges might this present?</h4>
<p>Try to think of an answer yourself before you hit the reveal button.</p>            
<button class="reveal-button" onclick="revealAnswer('stop-and-think-2')">Reveal</button>
            <p id="stop-and-think-2" style="display: none;">A local minimum is like a small valley or depression on the mountainside, but not the lowest valley. If you start nearby and follow the steepest downward path, you'll end up in this local valley rather than finding the deepest one. This represents a major challenge in optimization—gradient descent might get stuck in these suboptimal solutions because it only sees the local landscape, not the global picture. We'll explore this challenge more in later lessons.</p>
        </div>
        <div class="continue-button" onclick="showNextSection(35)">Continue</div>
    </section>

    <section id="section35">
        <h2>Review</h2>
        <div class="image-placeholder">
            <img src="images/ball.png?height=300&width=600" alt="Summary image shows the gradient descent process visualized as a ball rolling down a 3D cost function surface, with arrows indicating the negative gradient direction at different points, and key concepts labeled: learning rate, gradient, update rule, and convergence.">
        </div>
        <p>In this lesson, we've introduced gradient descent, a fundamental optimization algorithm in machine learning:</p>
        <ul>
            <li>Gradient descent iteratively adjusts parameters to minimize a cost function</li>
            <li>It works by calculating the gradient (direction of steepest increase) and moving in the opposite direction</li>
            <li>The update rule is \( \beta = \beta - \alpha\nabla_\beta C(\beta) \)</li>
            <li>The learning rate \( \alpha \) controls the step size and significantly impacts convergence</li>
            <li>This method makes it possible to train models on large datasets where direct solutions are impractical</li>
        </ul>
        <p>In the next lesson, we'll delve deeper into the mathematics of gradient descent and explore how to calculate gradients for different types of cost functions.</p>
<div class="continue-button" onclick="showNextSection(36)">Continue</div>
</section>


<section id="section36">
        <div class="faq-section">
            <h3>Frequently Asked Questions</h3>
            <h4>How do we know when to stop the gradient descent algorithm?</h4>
            <p>In practice, we use one or more stopping criteria:</p>
            <ol>
                <li>Maximum number of iterations: Stop after a predefined number of iterations.</li>
                <li>Threshold on the change in cost: Stop when the decrease in the cost function between iterations becomes very small.</li>
                <li>Threshold on the gradient magnitude: Stop when the gradient becomes very close to zero, indicating we're near a minimum.</li>
            </ol>
            <p>The specific criteria used depend on the application and computational resources available.</p>
        </div>
 </section>



    <script>
        // Show the first section initially
        document.getElementById("section1").style.display = "block";
        document.getElementById("section1").style.opacity = "1";

        function showNextSection(nextSectionId) {
            const currentButton = event.target;
            const nextSection = document.getElementById("section" + nextSectionId);
            
            currentButton.style.display = "none";
            
            nextSection.style.display = "block";
            setTimeout(() => {
                nextSection.style.opacity = "1";
            }, 10);

            setTimeout(() => {
                nextSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }, 500);
        }

        function revealAnswer(id) {
            const revealText = document.getElementById(id);
            const revealButton = event.target;
            
            revealText.style.display = "block";
            revealButton.style.display = "none";
        }

        function checkAnswer(questionId, correctAnswer) {
            const question = document.getElementById(questionId);
            const selectedAnswer = question.querySelector('input:checked');
            const feedback = document.createElement('p');
            
            if (selectedAnswer && selectedAnswer.id === correctAnswer) {
                feedback.textContent = "Correct!";
                feedback.style.color = "green";
            } else {
                feedback.textContent = "Incorrect. Try again!";
                feedback.style.color = "red";
            }
            
            question.appendChild(feedback);
        }

        function checkMatching() {
            const correctAnswers = {
                match1: "a",
                match2: "b",
                match3: "c",
                match4: "d"
            };
            
            let allCorrect = true;
            
            for (let i = 1; i <= 4; i++) {
                const select = document.getElementById(`match${i}`);
                const feedback = document.createElement('span');
                feedback.style.marginLeft = "10px";
                
                if (select.value === correctAnswers[`match${i}`]) {
                    feedback.textContent = "✓";
                    feedback.style.color = "green";
                } else {
                    feedback.textContent = "✗";
                    feedback.style.color = "red";
                    allCorrect = false;
                }
                
                select.parentNode.appendChild(feedback);
            }
            
            const overallFeedback = document.createElement('p');
            overallFeedback.textContent = allCorrect ? "All correct! Great job!" : "Some answers are incorrect. Try again!";
            overallFeedback.style.color = allCorrect ? "green" : "red";
            document.getElementById("test-your-knowledge-4").appendChild(overallFeedback);
        }

// Gradient Descent Animation - 4 iterations
function initGradientDescent4Iterations(canvasId) {
    // Get canvas and context
    const canvas = document.getElementById(canvasId);
    if (!canvas) return; // Skip if canvas element doesn't exist
    
    const ctx = canvas.getContext('2d');
    
    // Parameters for gradient descent
    const initialBeta = 5;
    const learningRate = 0.1;
    const numIterations = 10;
    const maxDisplayIterations = 4; // Only display first 4 iterations
    
    // Calculate all steps of gradient descent
    function calculateGradientDescent() {
        const betaValues = [initialBeta];
        const costValues = [initialBeta * initialBeta];
        
        let beta = initialBeta;
        for (let i = 0; i < numIterations; i++) {
            const gradient = 2 * beta; // Derivative of β²
            beta = beta - learningRate * gradient;
            betaValues.push(beta);
            costValues.push(beta * beta);
        }
        
        return { betaValues, costValues };
    }
    
    // Calculate once and store results
    const { betaValues, costValues } = calculateGradientDescent();
    
    // Current iteration to display
    let currentIteration = 0;
    
    // Canvas dimensions and margins
    const margin = { top: 30, right: 30, bottom: 50, left: 60 };
    const width = canvas.width - margin.left - margin.right;
    const height = canvas.height - margin.top - margin.bottom;
    
    // Define the coordinate bounds for our visualization
    const xMin = -6;
    const xMax = 6;
    const yMin = -1;
    const yMax = 30;
    
    // Colors
    const colors = {
        blue: '#4C72B0',
        red: '#C44E52',
        green: '#55A868',
        purple: '#8172B3',
        orange: '#CCB974',
        pink: '#DD8ACE',
        gray: '#E0E0E0',
        darkGray: '#444444'
    };
    
    // Functions to convert from data coordinates to canvas pixels
    function xToCanvas(x) {
        return margin.left + width * (x - xMin) / (xMax - xMin);
    }
    
    function yToCanvas(y) {
        return margin.top + height * (1 - (y - yMin) / (yMax - yMin));
    }
    
    // Draw the visualization for the current iteration
    function draw() {
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw grid
        drawGrid();
        
        // Draw axes
        drawAxes();
        
        // Draw the parabola (cost function)
        drawCostFunction();
        
        // Draw gradient descent path
        drawPath();
    }
    
    // Draw a light grid
    function drawGrid() {
        ctx.strokeStyle = colors.gray;
        ctx.lineWidth = 0.5;
        
        // Vertical grid lines
        for (let x = Math.floor(xMin); x <= Math.ceil(xMax); x++) {
            ctx.beginPath();
            ctx.moveTo(xToCanvas(x), yToCanvas(yMin));
            ctx.lineTo(xToCanvas(x), yToCanvas(yMax));
            ctx.stroke();
        }
        
        // Horizontal grid lines
        for (let y = Math.floor(yMin); y <= Math.ceil(yMax); y += 5) {
            ctx.beginPath();
            ctx.moveTo(xToCanvas(xMin), yToCanvas(y));
            ctx.lineTo(xToCanvas(xMax), yToCanvas(y));
            ctx.stroke();
        }
    }
    
    // Draw x and y axes
    function drawAxes() {
        ctx.strokeStyle = colors.darkGray;
        ctx.lineWidth = 2;
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        
        // X-axis
        ctx.beginPath();
        ctx.moveTo(xToCanvas(xMin), yToCanvas(0));
        ctx.lineTo(xToCanvas(xMax), yToCanvas(0));
        ctx.stroke();
        
        // X-axis ticks and labels
        ctx.fillStyle = colors.darkGray;
        for (let x = Math.floor(xMin); x <= Math.ceil(xMax); x += 2) {
            ctx.beginPath();
            ctx.moveTo(xToCanvas(x), yToCanvas(0) - 5);
            ctx.lineTo(xToCanvas(x), yToCanvas(0) + 5);
            ctx.stroke();
            
            ctx.fillText(x.toString(), xToCanvas(x), yToCanvas(0) + 20);
        }
        
        // X-axis label
        ctx.fillText('Parameter (β)', xToCanvas((xMax + xMin) / 2), yToCanvas(yMin) + 35);
        
        // Y-axis
        ctx.beginPath();
        ctx.moveTo(xToCanvas(0), yToCanvas(yMin));
        ctx.lineTo(xToCanvas(0), yToCanvas(yMax));
        ctx.stroke();
        
        // Y-axis ticks and labels
        ctx.textAlign = 'right';
        for (let y = 0; y <= yMax; y += 5) {
            ctx.beginPath();
            ctx.moveTo(xToCanvas(0) - 5, yToCanvas(y));
            ctx.lineTo(xToCanvas(0) + 5, yToCanvas(y));
            ctx.stroke();
            
            ctx.fillText(y.toString(), xToCanvas(0) - 10, yToCanvas(y) + 4);
        }
        
        // Y-axis label
        ctx.save();
        ctx.translate(xToCanvas(xMin) - 35, yToCanvas((yMax + yMin) / 2));
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.fillText('Cost: C(β)', 0, 0);
        ctx.restore();
    }
    
    // Draw the cost function curve
    function drawCostFunction() {
        ctx.strokeStyle = colors.blue;
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        for (let x = xMin; x <= xMax; x += 0.1) {
            const y = x * x; // Our cost function is C(β) = β²
            
            if (x === xMin) {
                ctx.moveTo(xToCanvas(x), yToCanvas(y));
            } else {
                ctx.lineTo(xToCanvas(x), yToCanvas(y));
            }
        }
        
        ctx.stroke();
        
        // Label for the cost function
        ctx.fillStyle = colors.blue;
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'left';
        ctx.fillText('Cost Function: C(β) = β²', xToCanvas(-5.5), yToCanvas(27));
    }
    
    // Draw the gradient descent path
    function drawPath() {
        // Path line
        ctx.strokeStyle = colors.red;
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        for (let i = 0; i <= currentIteration; i++) {
            const x = betaValues[i];
            const y = costValues[i];
            
            if (i === 0) {
                ctx.moveTo(xToCanvas(x), yToCanvas(y));
            } else {
                ctx.lineTo(xToCanvas(x), yToCanvas(y));
            }
        }
        
        ctx.stroke();
        
        // Draw points and arrows
        for (let i = 0; i <= currentIteration; i++) {
            const x = betaValues[i];
            const y = costValues[i];
            
            // Draw point
            ctx.fillStyle = colors.green;
            ctx.beginPath();
            ctx.arc(xToCanvas(x), yToCanvas(y), 5, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw arrow between points
            if (i < currentIteration) {
                drawArrow(
                    xToCanvas(betaValues[i]), yToCanvas(costValues[i]),
                    xToCanvas(betaValues[i+1]), yToCanvas(costValues[i+1])
                );
            }
        }
    }
    
    // Draw an arrow from (x1,y1) to (x2,y2)
    function drawArrow(fromX, fromY, toX, toY) {
        const headLength = 10;
        const angle = Math.atan2(toY - fromY, toX - fromX);
        
        // Draw the line
        ctx.strokeStyle = colors.purple;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(fromX, fromY);
        ctx.lineTo(toX, toY);
        ctx.stroke();
        
        // Draw the arrowhead
        ctx.fillStyle = colors.purple;
        ctx.beginPath();
        ctx.moveTo(toX, toY);
        ctx.lineTo(
            toX - headLength * Math.cos(angle - Math.PI/6),
            toY - headLength * Math.sin(angle - Math.PI/6)
        );
        ctx.lineTo(
            toX - headLength * Math.cos(angle + Math.PI/6),
            toY - headLength * Math.sin(angle + Math.PI/6)
        );
        ctx.closePath();
        ctx.fill();
    }
    
    // Animation function
    function animate() {
        // Move to next iteration
        currentIteration = (currentIteration + 1) % (maxDisplayIterations + 1);
        
        // If we reached the end, pause briefly before looping
        if (currentIteration === 0) {
            setTimeout(draw, 1000); // Pause for 1 second at the end
            setTimeout(animate, 1500); // Then continue
        } else {
            draw();
            setTimeout(animate, 800); // Normal animation speed
        }
    }
    
    // Start animation
    draw();
    setTimeout(animate, 800);
}

// Gradient Descent Animation - Until Minimum
function initGradientDescentUntilMin(canvasId) {
    // Get canvas and context
    const canvas = document.getElementById(canvasId);
    if (!canvas) return; // Skip if canvas element doesn't exist
    
    const ctx = canvas.getContext('2d');
    
    // Parameters for gradient descent
    const initialBeta = 5;
    const learningRate = 0.1;
    const costThreshold = 0.01; // Stop when cost is very close to 0
    
    // Calculate all steps of gradient descent until cost is near 0
    function calculateGradientDescent() {
        const betaValues = [initialBeta];
        const costValues = [initialBeta * initialBeta];
        
        let beta = initialBeta;
        let cost = beta * beta;
        let iterations = 0;
        
        // Continue until cost is very close to 0 or max iterations reached
        while (cost > costThreshold && iterations < 30) {
            const gradient = 2 * beta; // Derivative of β²
            beta = beta - learningRate * gradient;
            cost = beta * beta;
            
            betaValues.push(beta);
            costValues.push(cost);
            iterations++;
        }
        
        return { betaValues, costValues };
    }
    
    // Calculate once and store results
    const { betaValues, costValues } = calculateGradientDescent();
    const numIterations = betaValues.length - 1;
    
    // Current iteration to display
    let currentIteration = 0;
    
    // Canvas dimensions and margins
    const margin = { top: 30, right: 30, bottom: 50, left: 60 };
    const width = canvas.width - margin.left - margin.right;
    const height = canvas.height - margin.top - margin.bottom;
    
    // Define the coordinate bounds for our visualization
    const xMin = -6;
    const xMax = 6;
    const yMin = -1;
    const yMax = 30;
    
    // Colors
    const colors = {
        blue: '#4C72B0',
        red: '#C44E52',
        green: '#55A868',
        purple: '#8172B3',
        orange: '#CCB974',
        pink: '#DD8ACE',
        gray: '#E0E0E0',
        darkGray: '#444444'
    };
    
    // Functions to convert from data coordinates to canvas pixels
    function xToCanvas(x) {
        return margin.left + width * (x - xMin) / (xMax - xMin);
    }
    
    function yToCanvas(y) {
        return margin.top + height * (1 - (y - yMin) / (yMax - yMin));
    }
    
    // Draw the visualization for the current iteration
    function draw() {
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw grid
        drawGrid();
        
        // Draw axes
        drawAxes();
        
        // Draw the parabola (cost function)
        drawCostFunction();
        
        // Draw gradient descent path
        drawPath();
    }
    
    // Draw a light grid
    function drawGrid() {
        ctx.strokeStyle = colors.gray;
        ctx.lineWidth = 0.5;
        
        // Vertical grid lines
        for (let x = Math.floor(xMin); x <= Math.ceil(xMax); x++) {
            ctx.beginPath();
            ctx.moveTo(xToCanvas(x), yToCanvas(yMin));
            ctx.lineTo(xToCanvas(x), yToCanvas(yMax));
            ctx.stroke();
        }
        
        // Horizontal grid lines
        for (let y = Math.floor(yMin); y <= Math.ceil(yMax); y += 5) {
            ctx.beginPath();
            ctx.moveTo(xToCanvas(xMin), yToCanvas(y));
            ctx.lineTo(xToCanvas(xMax), yToCanvas(y));
            ctx.stroke();
        }
    }
    
    // Draw x and y axes
    function drawAxes() {
        ctx.strokeStyle = colors.darkGray;
        ctx.lineWidth = 2;
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        
        // X-axis
        ctx.beginPath();
        ctx.moveTo(xToCanvas(xMin), yToCanvas(0));
        ctx.lineTo(xToCanvas(xMax), yToCanvas(0));
        ctx.stroke();
        
        // X-axis ticks and labels
        ctx.fillStyle = colors.darkGray;
        for (let x = Math.floor(xMin); x <= Math.ceil(xMax); x += 2) {
            ctx.beginPath();
            ctx.moveTo(xToCanvas(x), yToCanvas(0) - 5);
            ctx.lineTo(xToCanvas(x), yToCanvas(0) + 5);
            ctx.stroke();
            
            ctx.fillText(x.toString(), xToCanvas(x), yToCanvas(0) + 20);
        }
        
        // X-axis label
        ctx.fillText('Parameter (β)', xToCanvas((xMax + xMin) / 2), yToCanvas(yMin) + 35);
        
        // Y-axis
        ctx.beginPath();
        ctx.moveTo(xToCanvas(0), yToCanvas(yMin));
        ctx.lineTo(xToCanvas(0), yToCanvas(yMax));
        ctx.stroke();
        
        // Y-axis ticks and labels
        ctx.textAlign = 'right';
        for (let y = 0; y <= yMax; y += 5) {
            ctx.beginPath();
            ctx.moveTo(xToCanvas(0) - 5, yToCanvas(y));
            ctx.lineTo(xToCanvas(0) + 5, yToCanvas(y));
            ctx.stroke();
            
            ctx.fillText(y.toString(), xToCanvas(0) - 10, yToCanvas(y) + 4);
        }
        
        // Y-axis label
        ctx.save();
        ctx.translate(xToCanvas(xMin) - 35, yToCanvas((yMax + yMin) / 2));
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.fillText('Cost: C(β)', 0, 0);
        ctx.restore();
    }
    
    // Draw the cost function curve
    function drawCostFunction() {
        ctx.strokeStyle = colors.blue;
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        for (let x = xMin; x <= xMax; x += 0.1) {
            const y = x * x; // Our cost function is C(β) = β²
            
            if (x === xMin) {
                ctx.moveTo(xToCanvas(x), yToCanvas(y));
            } else {
                ctx.lineTo(xToCanvas(x), yToCanvas(y));
            }
        }
        
        ctx.stroke();
        
        // Label for the cost function
        ctx.fillStyle = colors.blue;
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'left';
        ctx.fillText('Cost Function: C(β) = β²', xToCanvas(-5.5), yToCanvas(27));
    }
    
    // Draw the gradient descent path
    function drawPath() {
        // Path line
        ctx.strokeStyle = colors.red;
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        for (let i = 0; i <= currentIteration; i++) {
            const x = betaValues[i];
            const y = costValues[i];
            
            if (i === 0) {
                ctx.moveTo(xToCanvas(x), yToCanvas(y));
            } else {
                ctx.lineTo(xToCanvas(x), yToCanvas(y));
            }
        }
        
        ctx.stroke();
        
        // Draw points and arrows
        for (let i = 0; i <= currentIteration; i++) {
            const x = betaValues[i];
            const y = costValues[i];
            
            // Draw point
            ctx.fillStyle = colors.green;
            ctx.beginPath();
            ctx.arc(xToCanvas(x), yToCanvas(y), 5, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw arrow between points
            if (i < currentIteration) {
                drawArrow(
                    xToCanvas(betaValues[i]), yToCanvas(costValues[i]),
                    xToCanvas(betaValues[i+1]), yToCanvas(costValues[i+1])
                );
            }
        }
    }
    
    // Draw an arrow from (x1,y1) to (x2,y2)
    function drawArrow(fromX, fromY, toX, toY) {
        const headLength = 10;
        const angle = Math.atan2(toY - fromY, toX - fromX);
        
        // Draw the line
        ctx.strokeStyle = colors.purple;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(fromX, fromY);
        ctx.lineTo(toX, toY);
        ctx.stroke();
        
        // Draw the arrowhead
        ctx.fillStyle = colors.purple;
        ctx.beginPath();
        ctx.moveTo(toX, toY);
        ctx.lineTo(
            toX - headLength * Math.cos(angle - Math.PI/6),
            toY - headLength * Math.sin(angle - Math.PI/6)
        );
        ctx.lineTo(
            toX - headLength * Math.cos(angle + Math.PI/6),
            toY - headLength * Math.sin(angle + Math.PI/6)
        );
        ctx.closePath();
        ctx.fill();
    }
    
    // Animation function
    function animate() {
        // Move to next iteration
        currentIteration = (currentIteration + 1) % (numIterations + 1);
        
        // If we reached the end, pause briefly before looping
        if (currentIteration === 0) {
            setTimeout(draw, 1000); // Pause for 1 second at the end
            setTimeout(animate, 1500); // Then continue
        } else {
            draw();
            setTimeout(animate, 800); // Normal animation speed
        }
    }
    
    // Start animation
    draw();
    setTimeout(animate, 800);
}
    </script>
</body>
</html>
